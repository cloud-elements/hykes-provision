#!/usr/bin/env bash

bindir=
etcdir=
libdir=
cmd="${1}" ; shift

## Global utility functions #######################################################################
function pprint() {
  local blue='\033[1;34m'
  local green='\033[1;32m'
  local red='\033[1;31m'
  local normal='\033[0m'
  local white='\033[1;37m'

  while (( "$#" )); do
    case "${1}" in
      -n) local n='-n' ; shift ;;
      -q) local q='-q' ; shift ;;
      *)
        test -n "${1}" && test -n "${adj}" && local msg=${1}
        test -n "${1}" && test -z "${adj}" && local adj=${1}
        shift
      ;;
    esac
  done

  if [ -z "${q}" ]; then
    case "${adj}" in
      bad) echo -e ${n} "${red}${msg}${normal}" ;;
      good) echo -e ${n} "${green}${msg}${normal}" ;;
      head) echo -e ${n} "${blue}==>${normal} ${white}${msg}${normal}" ;;
      subhead) echo -e ${n} "${green}==>${normal} ${white}${msg}${normal}" ;;
      *) echo ${n} "${msg}" ;;
    esac
  fi
}

function read-config-path() {
  echo $(test -f "${etcdir}/hykes-provisioner" && sed -n '1p' < "${etcdir}/hykes-provisioner")
}

function write-config-path() {
  echo "${1}" > "${etcdir}/hykes-provisioner"
}

## Argument and option parsing ####################################################################
while (( "$#" )); do
  case "${1}" in
    --cloud-provider=*) cloud=${1/--cloud-provider=/''} ; shift ;;
    --consolidated) consolidated=0 ; shift ;;
    --dns-provider=*) dns=${1/--dns-provider=/''} ; shift ;;
    --path=*) path=${1/--path=/''} ; shift ;;
    --quiet) quiet='-q' ; shift ;;
    --specs=*) specs=${1/--specs=/''} ; shift ;;
    -C*) cloud=${2} ; shift ; shift ;;
    -D*) dns=${2} ; shift ; shift ;;
    -P*) path=${2} ; shift ; shift ;;
    -c) consolidated=0 ; shift ;;
    -q) quiet='-q' ; shift ;;
    -s*) specs=${2} ; shift ; shift ;;
    *)
      case "${cmd}" in
        init) test -n "${1}" && test -z "${path}" && path=${1} ;;
      esac
      case "${cmd}" in
        provision|unprovision)
          test -n "${1}" && test -n "${cloud}" && dns=${1}
          test -n "${1}" && test -z "${cloud}" && cloud=${1}
        ;;
      esac
      shift
    ;;
  esac
done

## Argument and option prompting ##################################################################
case "${cmd}" in
  init) test -z "${path}" && read -e -p 'Enter path: ' path ;;
esac
case "${cmd}" in
  provision|unprovision)
    test -z "${cloud}" && read -e -p 'Enter cloud provider (e.g. do, aws): ' cloud
    test -z "${dns}" && read -e -p 'Enter DNS provider (e.g. do, aws, hosts): ' dns
  ;;
esac

## Argument and option defaults ###################################################################
test -z "${path}" && path=$(read-config-path)
test -z "${specs}" && specs='medium'

## Command utility functions ######################################################################
function list-inventory-servers() {
  "${libdir}/hykes-blueprinter/build/bin/hykes-blueprinter" init "${path}" --quiet && \
  echo "$("${libdir}/hykes-blueprinter/build/bin/hykes-blueprinter" list-servers "${1}" --quiet)"
}
export -f list-inventory-servers

function lookup-inventory-fqdn() {
  local h=$(list-inventory-servers | head -n 1)
  echo "${h/app0./}"
}
export -f lookup-inventory-fqdn

# Cloud providers:
function await-do-server() {
  case "${2}" in
    active|inactive) tugboat wait "${1}" --state="${2}" ;;
    *)
      tugboat info "${1}" > /dev/null 2>&1
      case "$?" in
        0) await-do-server "${1}" "${2}";;
        *) return 0 ;;
      esac
    ;;
  esac
}
export -f await-do-server

function create-do-server() {
  tugboat create "${1}" --size="${2}"
}
export -f create-do-server

function destroy-do-server() {
  yes | tugboat destroy "${1}"
}
export -f destroy-do-server

function exists-do-server() {
  tugboat info "${1}" > /dev/null 2>&1
}
export -f exists-do-server

function lookup-do-server-ip() {
  echo "$(tugboat info -n "${1}" --attribute=ip4 --porcelain)"
}
export -f lookup-do-server-ip

function size-do-server() {
  case "${1}" in
    consolidated)
      local xsmall='512mb'
      local small='4gb'
      local medium='8gb'
      local large='16gb'
      local xlarge='64gb'

      echo "${!2}"
    ;;
    *) return 1 ;;
  esac
}
export -f size-do-server

function create-do-cloud() {
  local size=$(size-do-server consolidated "${specs}")
  echo "${1}" | xargs -I{} bash -c "create-do-server {} ${size}" && \
  echo "${1}" | xargs -I{} bash -c "await-do-server {} active"
}
export -f create-do-cloud

function destroy-do-cloud() {
  echo "${1}" | xargs -I{} bash -c "destroy-do-server {}" && \
  echo "${1}" | xargs -I{} bash -c "await-do-server {} destroyed"
}
export -f create-do-cloud

function exists-do-cloud() {
  echo "${1}" | xargs -I{} bash -c '! exists-do-server {}'
  case "$?" in
    0) return 1 ;;
    *) return 0 ;;
  esac
}
export -f exists-do-cloud

# DNS providers:
function create-hosts-map() {
  echo "${1} ${2}" | sudo tee -a /etc/hosts
}
export -f create-hosts-map

function destroy-hosts-map() {
  sudo sed -i '' "/^${1}/d" /etc/hosts
}
export -f destroy-hosts-map

function create-hosts-maps-consolidated() {
  local fqdn=$(lookup-inventory-fqdn)
  local all=$(list-inventory-servers)
  local app=$(list-inventory-servers 'app')
  local appcount=$(echo "${app}" | wc -l | tr ' ' '\0')

  # Loop through all consolidated servers, determine their IP, and then create map in
  # /etc/hosts. The primary loadbalance role, which exists on the first consolidated
  # server, needs to have "extra" records so that the core endpoints are reachable upon
  # the cloud being successfully built (e.g. api.example.com, console.example.com)
  for ((i=0; i<=appcount-1; i++)); do
    local a=$(echo "${app}" | sed -n "$(( ${i} + 1 ))p")
    local ip=$(lookup-do-server-ip "${a}") # TODO: Remove coupling
    local rs=$(echo "${all}" | grep "${i}." | tr '\n' ' ')
    if [ ${i} -eq 0 ]; then
      rs="${rs}${fqdn} api.${fqdn} console.${fqdn} logs.${fqdn}"
    fi

    create-hosts-map "${ip}" "${rs}"
  done
}
export -f create-hosts-maps-consolidated

function destroy-hosts-maps() {
  local srvcount=$(echo "${1}" | wc -l | tr ' ' '\0')

  for ((i=0; i<=srvcount-1; i++)); do
    local a=$(echo "${1}" | sed -n "$(( ${i} + 1 ))p")
    local ip=$(lookup-do-server-ip "${a}") # TODO: Remove coupling

    destroy-hosts-map "${ip}"
  done
}
export -f destroy-hosts-maps

## Command functions ##############################################################################
function help() {
  a=(${0//\// })
  bin=${a[${#a[@]}-1]}

  echo 'Usage:'
  echo "  ${bin} init <path> [--quiet|-q]"
  echo "  ${bin} provision <cloud-provider> <dns-provider>"
  echo '    [--consolidated|-c] [--specs|-s <xsmall|small|medium|large|xlarge>] [--quiet|-q]'
  echo "  ${bin} unprovision <cloud-provider> <dns-provider>"
  echo '    [--consolidated|-c] [--quiet|-q]'
  echo
  echo 'Configuration Commands:'
  echo '  init    Initialize to work against the given blueprint'
  echo
  echo 'Core Commands:'
  echo '  provision      Provision cloud'
  echo '  unprovision    Unprovision cloud'
  echo
  echo 'More Information:'
  echo '  chat    https://ce-success.herokuapp.com'
  echo '  docs    https://ce-onprem.readthedocs.org'
  echo '  repo    https://github.com/cloud-elements/hykes-provisioner'
}

function init() {
  pprint head 'Initializing' ${quiet}
  pprint subhead 'Configuring' ${quiet}
  write-config-path $(greadlink -f "${path}")
}

function provision() {
  pprint head 'Provisioning' ${quiet}

  case "${cloud}" in
    do)
      case "${consolidated}" in
        0)
          local app=$(list-inventory-servers 'app')

          pprint subhead 'Checking for existing cloud' ${quiet}
          ! exists-do-cloud "${app}" || \
            { pprint bad 'failed (cloud should not exist)' ${quiet} ; return 1; }

          pprint subhead 'Creating cloud' ${quiet}
          create-do-cloud "${app}" || { pprint bad 'failed' ${quiet} ; return 1; }

          case "${dns}" in
            hosts)
              pprint subhead 'Creating DNS' ${quiet}
              create-hosts-maps-consolidated || { pprint bad 'failed' ${quiet} ; return 1; }
            ;;
          esac
        ;;
      esac
    ;;
  esac
}

function unprovision() {
  pprint head 'Unprovisioning' ${quiet}

  case "${cloud}" in
    do)
      case "${consolidated}" in
        0)
          local app=$(list-inventory-servers 'app')

          pprint subhead 'Checking for existing cloud' ${quiet}
          exists-do-cloud "${app}" || \
            { pprint bad 'failed (cloud should exist)' ${quiet} ; return 1; }

          case "${dns}" in
            hosts)
              pprint subhead 'Destroying DNS' ${quiet}
              destroy-hosts-maps "${app}" || { pprint bad 'failed' ${quiet} ; return 1; }
            ;;
          esac

          pprint subhead 'Destroying cloud' ${quiet}
          destroy-do-cloud "${app}" || { pprint bad 'failed' ${quiet} ; return 1; }
        ;;
      esac
    ;;
  esac
}

function version() {
  echo 'v0.0.0'
}

## Command routing ################################################################################
case "${cmd}" in
  --help|-h) help ; exit 0 ;;
  --version|-v) version ; exit 0 ;;
  init|provision|unprovision) "${cmd}" ; exit "$?" ;;
  *) help ; exit 1 ;;
esac
